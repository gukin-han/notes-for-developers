# 07 Deadlocks

## 교착상태 (deadlock)

![스크린샷 2023-03-01 오후 5.31.24.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.31.24.png)

- 사거리가 완전히 막혀있는 상황
- 더 이상 방법이 없는 상황
- 특정 차들을 끄집어 내든지 → 오버헤드가 큰 작업 → 누군가 희생을 하면 해결

## The Deadlock Problem

- Deadlock
    - 일련의 프로세스들이 서로 가진 자원을 기다리며 block된 상태
- Resource (자원)
    - 하드웨어, 소프트웨어 등을 포함하는 개념
    - 예) I/O device, CPU cycle, memory space, semaphore 등
    - 프로세스가 자원을 사용하는 절차
        - Request, Allocate, Use, Release
- Deadlock Example 1
    - 시스템에 2개의 tape drive가 있다
    - 프로세스 P1과 P2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리고 있다
- Deadlock Example 2
    - Binary semaphores A and B
        
        ![스크린샷 2023-03-01 오후 5.37.03.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.37.03.png)
        

## 📌 Deadlock 발생의 4가지 조건

> 데드락의 4가지 조건?
> 
- **Mutual exclusion** (상호 배제)
    - 매 순간 하나의 프로세스만이 자원을 사용할 수 있음
- **No preemption** (비선점)
    - 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음 → 📝 빼앗길 수 있으면 해결
- **Hold and wait** (보유대기)
    - 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
- **Circular wait**(순환대기)
    - 자원을 기다리는 프로세스간에 사이클이 형성되어야함
    - 프로세스 P0, P1, …, Pn 이 있을때
        
        ![스크린샷 2023-03-01 오후 5.39.38.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.39.38.png)
        

## Resource-Allocation Graph (자원할당그래프)

> 데드락이 발생했는지를 자원할당그래프를 그려서 알아본다
> 

![스크린샷 2023-03-01 오후 5.41.59.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.41.59.png)

- 화살표 두 가지 종류
    - 자원에서 프로세스로 나가는 화살표: 이 자원이 이 프로세스에 속해있다
    - 프로세스에서 자원으로 나가는 화살표: 이 프로세스가 이 자원을 요청 (아직 획득하지 못함; Request)
- 작은 점들 → instance 수
- 이 상황이 데드락이냐 아니냐 체크: 📝 위 그림은 데드락이 아니다 → 사이클이 없기 때문
    
    ![스크린샷 2023-03-01 오후 5.44.15.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.44.15.png)
    
    - 그래프에 cycle이 없으면 **deadlock**이 아니다
    - 그래프에 cycle이 있으면
        - 📌 if **only one instance per resource type**, then **deadlock**
        - if several instance per resource type, possibility of deadlock
    - 왼쪽 - 데드락임 ← 자원2가 두 개를 들고 있지만, 모두 점유되고 있고 사이클이 형성
    - 오른쪽 - 사이클은 있지만, 자원이 두개씩 존재함, 자원1이 하나의 인스턴스를 가지고 있었다면 데드락이지만 두개를 가지고 있고, p2혹은 p4가 쓰고나서 반납을 하면 해결이 된다.

## Deadlock의 처리 방법

- 미연의 데드락 방지
    - **Deadlock Prevention**
        - 자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것
    - **Deadlock Avoidance**
        - 자원 요청에 대한 📌 **부가적인 정보**를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당
        - 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당
- 데드락 발생 → 후 조치 혹은 방치
    - **Deadlock Detection and recovery**
        - Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover
    - 📌 **Deadlock Ignorance (현대 OS 채택)**
        - Deadlock을 시스템이 책임지지 않음
        - UNIX를 포함한 대부분의 OS가 채택
        - 유저가 알아서 처리 ← 데드락은 빈번히 발생하지 않기 때문에 (위 방지법은 오버헤드가 크기도 하고)

## Deadlock Prevention

- **Mutual Exclusion**
    - 공유해서는 안되는 자원의 경우 반드시 성립해야 함
- **Hold and Wait**
    - 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다
    - 방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
    - 방법 2. 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청
- **No preemption (= 빼앗아 올 수 있게 허락)**
    - process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨
    - 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다
    - State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용 (CPU, memory)
    - 📝 CPU는 항상 preemptive → 데드락이 생기지 않음 → CPU는 현재 사용 상태를 save하고 restore할 수 있는 자원이기 때문
- **Circular Wait (꼬리에 꼬리를 물고)**
    - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
    - 예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원을 Rj을 할당받기 위해서는 우선 Rj를 release 해야 한다
    - 자원에 순서를 붙여서, 특정 자원을 가지려면 다른 자원을 먼저 획득해야 자격이 생긴다.

⇒ Utilization 저하, throughput 감소, starvation 문제 

## Deadlock Avoidance

- Deadlock avoidance
    - 자원 요청에 대한 부가적인를 이용해서 자원할당이 deadlock으로 부터 안전 (safe) 한지를 동적으로 조사해서 안전한 경우에만 할당
    - 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법임
- **safe state**
    - 시스템 내의 프로세스들에 대한 📌 **safe sequence**가 존재하는 상태
        - **safe sequence**
            - 프로세스의 sequence < P1, P2, …, Pn> 이 safe하려면 Pi (1 ≤ i ≤ n)의 자원 요청이 “**가용 자원 + 모든 Pj (j < i)의 보유 자원**”에 의해 충족되어야 함
            - 조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장
                - Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj(j<i)가 종료될 때까지 기다린다
                - Pi-1이 종료되면 Pi의 자원요청을 만족시켜 수행한다

![스크린샷 2023-03-01 오후 6.12.51.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.12.51.png)

- 시스템이 safe state에 있으면 ⇒ no deadlock
- 시스템이 unsafe state에 있으면 ⇒ possibility of deadlock
- Deadlock Avoidance
    - 시스템이 unsafe state에 들어가지 않는 것을 보장
    - 2가지 경우의 avoidance 알고리즘
        - Single instance per resource types
            - **📌 Resource Allocation Graph algorithmm 사용**
        - Multi instance per resource types
            - **📌 Banker’s Algorithm 사용**

## Resource Allocation Graph algorithm

- 📌 **Claim edge** Pi → Rj
    - 📌 프로세스 Pi가 자원 Rj를 미래에 요청할 수 있음을 뜻함 (**점선**으로 표시)
    - 프로세스가 해당 자원 요청시 request edge로 바뀜 (실선)
    - Rj가 release되면 assignment edge는 다시 claim edge로 바뀐다
- Request edge의 assignment edge 변경시 (점선을 포함하여) cycle이 생기지 않는 겨우에만 요청 자원을 할당한다
- Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O(n^2)시간이 걸린다.

![스크린샷 2023-03-01 오후 6.18.55.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.18.55.png)

> Deadlock avoidance는 최악의 상황을 가정 → 즉 데드락의 가능성이 있는 프로세스에 대해 자원을 주지 않는다
> 

## Banker’s Algorithm

- Example
    
    ![스크린샷 2023-03-01 오후 6.21.21.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.21.21.png)
    

> 📝 메모
- 현재의 **가용 자원 전체**를 가지고 Need의 충족이 가능한지를 파악하고 할당한다. → P1, P3가 최대 요청을 해도 해결 가능 → 종료시 자원을 돌려 받고 나머지를 수행

- 즉, 최악의 경우를 가정하기 때문에, 그 프로세스가 종료까지의 최대 요청 자원들이 언제 요청될지 모르기 때문에 현재 가지고 있는 자원이 최대 요청 자원을 만족하지 않으면 자원을 할당하지 않는다. 굉장히 보수적

- 사실 데드락이 거의 발생하지 않는다.
> 

## Deadlock Detection and Recovery

- Deadlock Detection
    - Resource type 당 single instance인 경우
        - 자원할당 그래프에서 cycle이 곧 deadlock을 의미
    - Resource type 당 multiple instance인 경우
        - Banker’s algorithm과 유사한 방법 활용 (📌 테이블 > 그래프)

![스크린샷 2023-03-01 오후 9.55.11.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.55.11.png)

- **Wait-for graph** 알고리즘
    - Resource type당 **single instance** 인 경우
    - Wait-for graph
        - 자원할당 그래프의 변형
        - 프로세스만으로 node 구성 (자원을 빼버리고)
        - Pj가 가지고 있는 자원을 Pk가 기다리는 경우 Pk → Pj
    - Algorithm
        - Wait-for graph에 사이클이 존재하는지 주기적으로 조사
        - O(n^2) → 사이클을 찾는 오버헤드
            - 최대의 경우 n개의 프로세스에서 나오는 n-1개의 화살표가 나옴
            - n(n-1) == n^2 (DFS; 깊이 우선 탐색)

![스크린샷 2023-03-01 오후 10.00.34.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.00.34.png)

- 현재 요청된게 없는 프로세스로 부터, 자원을 반납 받는다고 가정 (낙관적)
- 예) P0, P2의 자원이 반납될 것이다.
- 만약 P2가 자원C 하나를 요청한다면? P0가 반납된다고 가정해도 deadlock이 된다. 왜? 요청한 자원을 받기전에 자원을 내놓지 않는다는 가정이 있기 때문에. → Deadlock 발견
    - Recovery
        - **Process termination**
            - Abort **all** deadlocked processes
            - Abort **one process at a time** until the deadlock cycle is eliminated
        - **Resource Preemption**
            - 비용을 최소화할 victim의 선정
            - safe state로 rollback하여 process를 restart
            - Starvation 문제
                - 동일한 프로세스가 계속해서 victim으로 선정되는 경우
                - cost factor에 rollback 횟수도 같이 고려

## Deadlock Ignorance

- 데드락이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음
    - 데드락이 매우 드물게 발생하므로 데드락에 대한 조치 자체가 더 큰 오버헤드일 수 있음
    - 만약, 시스템에 데드락이 발생하는 겨우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 process를 죽이는 등의 방법으로 대처
    - UNIX, Windows 등 대부분의 범용 OS가 채택