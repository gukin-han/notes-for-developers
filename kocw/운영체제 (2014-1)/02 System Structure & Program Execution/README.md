# 02 System Structure & Program Execution

## 컴퓨터 시스템 구조

![스크린샷 2023-02-27 오후 3.45.16.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.45.16.png)

- 컴퓨터 시스템의 하드웨어를 간단하게 요약해서 보여준 그림
- 메모리
    - CPU의 작업 공간
    - 매 클럭 사이클 마다 instruction을 읽어와서 실행함
    - 메모리를 전담하는 controller가 있음
- DMA controller
    - I/O의 빈번한 interrupt를 막기 위해
    - DMA가 직접 메인 메모리로 복사를 해서 CPU에 한번만 interrupt를 걸게 한다
- I/O Device
    - 하드 디스크/ 키보드/ 모니터
- Device controller
    - I/O device에서 CPU 역할을 함
- Local buffer
    - CPU의 작업 공간이 memory 이듯이, local buffer가 그 역할을 함
- mode bit
    - 현재 CPU에서 실행되는 것이 📌 운영체제인지, 사용자 프로그램인지 구분하는 역할
- Interrupt line
    - CPU는 항상 메모리내의 instruction을 실행함
    - 따라서, I/O Device와의 커뮤니케이션을 위함
        - 키보드에서 읽어오는 것과 화면에 출력하는 등 ← I/O Device에 접근하는 instruction
- 📌 timer → 📝 time sharing을 구현하기 위한 하드웨어
    - CPU가 특정 사용자 프로그램에 독점되는것을 막기 위함
    - timer에 값을 설정하여 사용자 프로그램에 CPU를 넘겨줌
    - 이 사용자 프로그램은 할당된 시간 (수십 ms) 동안 본인의 instruction을 실행함
    - 할당된 시간이 끝나면 timer interrupt를 걸어, OS에 운영권이 넘어감
    - instruction 실행 → interrupt line 체크 → instruction 실행 → instrrupt line 체크

## 📌 Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 📌 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원
    
    ![스크린샷 2023-02-27 오후 4.04.15.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.04.15.png)
    
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드(커널 모드)에서만 수행 가능한 ‘특권명령’으로 규정
    - Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅
        
        ![스크린샷 2023-02-27 오후 4.05.36.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.05.36.png)
        

## Timer

- 타이머
    - 저해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
    - 타이머는 매 클럭 틱 때마다 1씩 감소
    - 타이머 값이 0이 되면 타이머 인터럽트 발생
    - CPU를 특정 프로그램이 독점하는 것으로 부터 보호
- 타이머는 time sharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

## Device Controller

- I/O device controller
    - 📌 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해 control register, status register를 가짐
    - **local buffer**를 가짐 (일종의 **data register**)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

> 📝 device driver (장치구동기): OS 코드 중 각 장치별 처리루틴 → **software**
📝 **device controller** (장치제어기): 각 장치를 통제하는 일종의 작은 CPU → hardware
> 

## 입출력 (I/O)의 수행

- 📌 모든 입출력 명령은 **특권 명령** → 커널에 의해서만 명령어 실행
- 그러면 사용자 프로그램은 어떻게 I/O를 하는가?
    - 이를 위해 📌 **시스템 콜 (System Call)** 을 이용함
        - 사용자 프로그램은 운영체제에게 I/O를 요청하는 방식을 이용 (= System Call)
    - **trap**을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
    - 올바른 I/O 요청인지 확인 후 I/O 수행
    - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

> 📝 I/O요청을 할때는 소프트웨어 인터럽트를 통해서 요청, I/O가 다 끝나면 하드웨어 인터럽트를 통해서 끝났다는 것을 알린다 → 두 가지 모두 필요하다.
> 

## 인터럽트 (Interrupt)

> 인터럽트의 종류와 트랩의 세부 구분은?
> 
- 인터럽트
    - 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- Interrupt (넓은 의미)
    - Interrupt (하드웨어 인터럽트): **하드웨어**가 발생시킨 인터럽트
    - 📌 **Trap** (소프트웨어 인터럽트)
        - **Exception**: 프로그램이 오류를 범한 경우
        - System call: 프로그램이 커널 함수를 호출하는 경우
- 인터럽트 관련 용어
    - 인터럽트 벡터
        - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - **인터럽트 처리 루틴** (= Interrupt Sevice Routine, 인터럽트 핸들러)
        - 해당 인터럽트를 처리하는 **커널 함수**

> 📝 인터럽트 종류가 많다. 즉, 인터럽트가 들어왔을때 각각 운영체제가 해야할일이 다르다. 운영체제 코드에 각각 정의가 되어있다. 인터럽트 마다 처리해야할 코드를 인터럽트 처리 루틴이라고 한다. 그러면, 인터럽트가 들어왔을때, 1번이 들어왔을때와 2번이 들어왔을때 어디로 가야할지를 표시하는 곳이 **인터럽트 벡터**이다. 즉, 📌 **함수의 주소를 정의해놓은 테이블을 인터럽트 벡터**라고 부른다.
> 

## 📌 시스템콜 (System Call)

- 시스템콜
    
    ![스크린샷 2023-02-27 오후 4.49.01.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.49.01.png)
    
    - 사용자 프로그램이 운영체제의 서비스를 받기 위해 **커널 함수를 호출**하는 것

## 동기식 입출력과 비동기식 입출력

![스크린샷 2023-02-27 오후 5.35.01.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.35.01.png)

- 동기식 입출력 (synchronous I/O) - 📝 현재 진행 중인 사용자 프로그램 관점
    - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
    - 구현 방법 1 (점유)
        - **I/O가 끝날 때까지 CPU를 낭비**시킴
        - 매시점 하나의 I/O만 일어날 수 있음
    - 구현 방법 2 (비점유)
        - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
        - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
        - 📌 **다른 프로그램에게 CPU를 줌** (일반적으로)
- 비동기식 입출력 (asynchronous I/O)
    - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
    - 예) write() 은 비동기식 입출력이 자연스럽다. 하지만, 구현하기 나름.

> 📝 두 경우 모두 I/O의 완료는 인터럽트로 알려줌
📝 동기식과 비동기식을 비교하면, CPU의 점유와 관계없이 instruction을 실행하면 비동기식, 언젠가 입출력이 완료되겠지만, 그 전에 instruction을 실행하면 비동기식
> 

## DMA (Direct Memory Access)

![스크린샷 2023-02-27 오후 5.45.31.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.45.31.png)

- DMA (Direct Memory Access)
    - 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
    - CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
    - 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

> 원래는 메모리 접근에 CPU만 가능하다. 따라서, I/O장치들이 메모리에 접근을 하고자 하면, 인터럽트를 통해서 행해진다. 하지만, 워낙 I/O 장치가 다양하고, 송수신되는 데이터의 규모나, 빈번함에 의해 CPU에 장애 요소가 되어 비효율적일 수 있다 → DMA를 통한 메모리 직접 접근을 가능하게 함. 예) 메모리에 I/O 데이터를 카피한다.
> 

## 서로 다른 입출력 명령어

![스크린샷 2023-02-27 오후 5.47.09.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.47.09.png)

- I/O를 수행하는 special instrunction에 의해 (좌측 → 일반적 I/O)
- Memory Mapped I/O에 의해 (우측)
    - 즉 메모리 주소의 연장 주소를 I/O device에 붙인다.

## 📌 저장장치 계층 구조

![스크린샷 2023-02-27 오후 5.49.43.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.49.43.png)

- 맨 위에 CPU
- 속도, 비용, 휘발성의 특성으로 용도에 맞게 구성한다.
    - 📌 **CPU에 가까울 수록 속도가 빠르고, 단위 공간당 비싸고 (용량이 적고), 휘발성이 크다.**
- 그린 → 휘발성, 레드 → 비휘발성
- CPU에서 직접 접근하여 처리하는 (📌 byte 단위로 접근) → Primary (Excutable)
- Sector 단위로 접근 → Secondary → 예를 들어, disk

> 📌 Cashing: 재사용을 목적으로 빠른 저장 시스템으로 정보를 옮김. 어떤 정보를 옮길지에 대한 것은 → 메모리 관리에서 다뤄진다.
> 

## 프로그램의 실행 (메모리 load)

![스크린샷 2023-02-27 오후 6.02.46.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.02.46.png)

- 프로그램은 파일 형태로 보관 → 메모리에 올라감
- 바로 올라가지 않고 중간 단계(가상메모리)가 있음
    - 📌 **프로그램마다 독자적인 주소 공간 (virtual memory)** 을 가지고 있음
    - 가상메모리는 코드, 데이터, 스택의 구조를 가지고 있음
- 메모리 주소변환 → 하드웨어의 지원

## 커널 주소 공간의 내용

![스크린샷 2023-02-27 오후 6.03.36.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.03.36.png)

- code
    - 인터럽트가 들어왔을때 처리 방법들이 코드로 작성되어 커널의 코드 부분에 들어있다.
- data
    - 운영체제에 사용되는 여러 자료 구조들이 data에 있다.
    - 하드웨어들을 관리하기 위한 자료구조들도 정의가 되어있다.
    - 각 프로세스들의 독자적인 주소공간을 관리하기 위한 자료구조 → PCB
- stack
    - 사용자 프로그램마다 커널 스택을 별도로 가지고 있다.

## 사용자 프로그램이 사용하는 함수

![스크린샷 2023-02-27 오후 6.14.13.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.14.13.png)

- 모든 프로그램이 함수 구조로 작성되어있다.
- 함수 (function)
    - 사용자 정의 함수 (프로세스의 Address space)
        - 자신의 프로그램에서 정의한 함수
    - 라이브러리 함수 (프로세스의 Address space)
        - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
        - 자신의 프로그램의 실행 파일에 포함되어 있다
    - 📌 커널 함수 (커널의 Address space)
        - 운영체제 프로그램의 함수
        - 📌 **커널 함수의 호출 = 시스템 콜**

> jump는 code 내 (논리주소 내)에서 하는 것. 프로세스에서 kernel로 가는 것은 불가능. 이를 위해서 시스템 콜을 이용한다.
> 

## 프로그램의 실행

![스크린샷 2023-02-27 오후 6.16.51.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-02-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.16.51.png)

- A라는 프로그램이 실행되어서 종료될 때 까지의 모습
- 시스템 콜을 하는 순간 커널 모드로 CPU가 동작하고, 커널의 주소공간에 있는 code내의 코드가 실행된다.
- 유저 모드에서 라이브러리 함수를 호출하면, 여전히 프로그램의 주소공간내의 코드를 실행한다.
- 즉, 유저 모드 → 커널 모드 → 유저 모드… 를 반복한다.