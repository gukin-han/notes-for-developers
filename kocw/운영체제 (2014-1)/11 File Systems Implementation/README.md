# 11 File Systems Implementation

## Allocation of file data in disk

> 디스크에 파일을 저장 → 읽기/쓰기에 영향
> 
- contiguous allocation
- linked allocation
- indexed allocation

### **📂 Contiguous Allocation**

> 연속해서 할당
> 

![스크린샷 2023-03-02 오후 6.01.19.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.01.19.png)

- 단점
    - 균일하지 않은 외부조각이 생길 수 있다(external fragmentation) → 비어있는 공간일지라도 활용 불가
    - file glow 가 어려움
        - file 생성시 얼마나 큰 hole을 배당할 것인가?
        - glow 가능 vs 낭비 (internal fragmentation)
- 장점
    - fast I/O
        - 한번의 seek/rotation으로 많은 바이트 transfer
        - realtime file (deadline)용으로, 또는 이미 run 중이던 process의 swapping용
    - direct access (= random access) 가능

### **📂 Linked Allocation**

![스크린샷 2023-03-02 오후 6.11.20.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.11.20.png)

- 장점
    - External fragmentation 발생 안함
- 단점
    - No random access ⇒ 📌 디스크는 본래 직접 접근이 가능하지만, 데이터 관리 방법에 영향을 받음
    - reliability 문제
        - 한 sector가 고장나(bad sector) pointer가 유실되면 많은 부분을 잃음
    - pointer를 위한 공간이 block의 일부가 되어 **공간 효율성**을 떨어뜨림 (practical한 문제)
        - 512 bytes/sector, 4 bytes/pointer ⇒ 512-4n bytes
- 변형
    - **file-allocation table (FAT)** 파일 시스템
        - 포인터를 별도의 위치에 보관하여 reliability와 공간효율성 문제 해결

### **📂 Indexed Allocation**

![스크린샷 2023-03-02 오후 6.22.12.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.22.12.png)

- 장점
    - External fragmentation 이 발생하지 않음
    - direct access 가능
- 단점
    - small file의 경우 공간 낭비 (실제로 많은 file들이 small)
    - too large file의 경우 하나의 block으로 index를 저장하기에 부족
        - 해결방안
            1. linked scheme ⇒ 다 커버가 안되면 또 다른 인덱스를 마지막에 추가
            2. multi-level index ⇒ 인덱스가 다른 인덱스를 가리키도록 (공간 낭비)

## UNIX 파일 시스템의 구조

![스크린샷 2023-03-02 오후 6.26.55.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.26.55.png)

### 📂 유닉스 파일 시스템의 중요 개념

- boot block
    - 부팅에 필요한 정보 (bootstrap loader)
    - 어떤 파일 시스템이라도 boot block이 맨 앞으로 나온다
- superblock
    - 파일 시스템에 관한 총체적인 정보를 담고 있다.
- 📌 Inode
    - 파일 이름을 제외한 파일의 모든 **메타 데이터**를 저장
    - 파일 하나당 Inode하나씩
        - 파일 크기에 따라
            - direct
            - indirect → 큰 파일을 표현 ( direct < single < double < triple)
            - 대부분이 작은 파일들
- data block
    
    ![스크린샷 2023-03-02 오후 6.32.46.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.32.46.png)
    
    - 파일의 실제 내용을 보관
    - 파일의 이름은 디렉토리가 가지고 있고 나머지 정보는 Inode 번호를 이용

## FAT File System

![스크린샷 2023-03-02 오후 6.40.48.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.40.48.png)

- bad sector로 인한 link 유실을 방지하기 위함
- 다음 위치를 찾기 위해 FAT을 확인 (직접 접근이 가능 ⇒ 작은 테이블이기 때문)
- 여러 카피의 FAT을 가짐
- indexed allocation을 완전히 극복

## Free-space Management

> 비어있는 블록 관리법
> 

![스크린샷 2023-03-02 오후 6.48.21.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.48.21.png)

### **📂 bit map or bit vector**

- bit map은 **부가적인 공간을 필요**로 함
- 연속적인 n개의 free block을 찾는데 효과적

### **📂 Linked list**

![스크린샷 2023-03-02 오후 6.57.47.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.57.47.png)

- 모든 free block들을 링크로 연결 (free list)
- 연속적인 가용공간을 찾는 것은 쉽지 않다
- 공간의 낭비가 없다

### **📂 Grouping**

![스크린샷 2023-03-02 오후 8.37.21.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.37.21.png)

- linked list 방법의 변형 ⇒ index 형식으로 grouping
- 첫번째 free block이 n개의 pointer를 가짐
    - n-1 포인터는 free data block을 가리킴
    - 마지막 포인터가 가리키는 block은 또 다시 n 포인터를 가짐

### **📂 Counting**

- 프로그램들이 종종 여러 개의 **연속적인 block을 할당하고 반납**한다는 성질에 착안
- (first free block, # of contiguous free blocks)을 유지

## 디렉토리 구현 (Directory Implementation)

- Linear list
    - <file name, file의 metadata>의 list
    - 구현이 간단
    - 디렉토리 내에 파일이 있는지 찾기 위해서는 linear search 필요 (**time-consuming**)
- Hash table
    - hash 함수 적용 → 함수의 아웃풋을 file name으로 사용
    - linear list + hashing
    - hash table은 file name을 이 파일의 linear list의 위치로 바꿔줌
    - search time을 없앰
    - **collision** 발생 가능 → 흔히 발생하는 현상 → 자료구조 시간에 다룸

![스크린샷 2023-03-02 오후 8.40.31.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.40.31.png)

- file의 metadata의 보관 위치
    - 디렉토리 내에 직접 보관
    - 디렉토리에는 포인터를 두고 다른 곳에 보관
        - inode, FAT 등
- long file name의 지원 (긴 파일 이름)
    - <file name, file의 metadata>의 list에서 각 entry는 일반적으로 고정 크기
    - file name이 고정 크기의 entry 길이보다 길어지는 경우 entry의 마지막 부분에 이름의 뒷부분이 위치한 곳의 포인터를 두는 방법
    - 이름의 나머지 부분은 동일한 directory file의 일부에 존재

## VFS and NFS

![스크린샷 2023-03-02 오후 8.50.14.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.50.14.png)

- Virtual File System (VFS)
    - 서로 다른 다양한 file system에 대해 📌 **동일한 시스템 콜 인터페이스 (API)를 통해 접근**할 수 있게 해주는 OS의 layer
- Network File System (NFS)
    - 분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있음
    - NFS는 분산 환경에서의 대표적인 파일 공유 방법임
    - NFS에서 원격으로 접근하듯이 (클라이언트 → 서버 → 클라이언트)

## Page cache and buffer cache

> ❓ page cache와 buffer cache의 차이점?
앞의 내용을 통합적으로 정리
> 
- **page cache**
    - virtual memory의 paging system에서 사용하는 page frame을 caching의 관점에서 설명하는 용어
    - memory-mapped I/O를 쓰는 경우 file의 I/O에서도 page cache 사용
- **memory-mapped I/O(file)**
    - file의 일부를 virtual memory에 mapping시킴 ⇒ 메모리에 읽고 쓰는 (=파일에 읽고 쓰는)
    - 매핑시킨 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 함
    - copy해서 주는 방식이 아니라 파일 입출력을 하는 방식
- **buffer cache (kernel)**
    - 파일시스템을 통한 I/O 연산은 메모리의 특정 영역인 buffer cache 사용
    - file 사용의 locality 활용
        - 한번 읽어온 block에 대한 후속 요청시 buffer cache에서 즉시 전달
    - 모든 프로세스가 공용으로 사용
    - replacement algorithm 필요 (LRU, LFU 등)
    - 단위: 논리적인 블록 (섹터 단위, 예전에는 512B)
- **unified buffer cache**
    - 최근의 OS에서는 기존의 bugger cache가 page cache에 통합됨 ⇒ buffer cache도 page단위로 관리

![스크린샷 2023-03-02 오후 9.01.09.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.01.09.png)

![스크린샷 2023-03-02 오후 9.12.36.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.12.36.png)

- 기존의 방식은 buffer cache의 내용을 카피해서 사용. read write시 항상 운영체제의 도움을 받아서 사용
- memory-mapped도 시스템 콜을 함. 디스크에 있는 파일을 읽어오고 (buffer cache로 부터) page cache에 올려주면 (memory mapped) → read, write. 운영체제의 도움을 받지 않고 자신의 메모리에 접근하듯이 사용할 수 있음
- 두 가지의 공통점은 buffer cache의 루틴을 항상 통과해야함

![스크린샷 2023-03-02 오후 9.14.29.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.14.29.png)

- page cache가 바로 맵핑

## 프로그램의 실행

![스크린샷 2023-03-02 오후 9.17.08.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.17.08.png)

![스크린샷 2023-03-02 오후 9.19.33.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.19.33.png)

- 코드 부분은 swap으로 쫓겨나지 않는다. → mapping해서
- 중간의 데이터 파일을 불러올때 mmap()을 사용 → 물리적 메모리에 올려서 운영체제의 도움없이 바로 사용