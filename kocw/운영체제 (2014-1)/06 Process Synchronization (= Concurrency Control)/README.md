# 06 Process Synchronization (= Concurrency Control)

⇒ 프로세스 동기화 (= 병행 제어)

## 데이터의 접근

![스크린샷 2023-03-01 오후 12.10.21.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.10.21.png)

> 📌 데이터가 저장된 위치가 있고, 데이터를 가져와서 연산 후 다시 데이터를 저장하는 경로를 거친다.
📌 데이터를 읽기만 하면 문제가 없지만, 여러 연산 주체가  동시에 쓰기를 하여 저장을 하려는 경우 문제가 생김
> 

## 📌 Race Condition (경쟁 상태)

![스크린샷 2023-03-01 오후 12.12.32.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.12.32.png)

> 📝 Note
- 여러 주체가 하나의 데이터를 동시에 접근하려고 할때 → Race condition (경쟁 상태)
- 이런 문제가 빈번하게 생길까? yes
- 프로세스가 각자의 주소공간을 접근하는 경우, 문제가 없을 수 있지만, I/O를 하는 경우 (커널)
- 프로세스끼리 공유 메모리를 가지는 경우
> 

## OS에서 race condition은 언제 발생하는가?

- kernel 수행 중 인터럽트 발생 시
- Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
- Multi processor에서 shared memory 내의 kernel data

## OS에서의 race condition (1/3) - interruppt handler - v.s. kernel

![스크린샷 2023-03-01 오후 12.20.30.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.20.30.png)

- `Count--`은 반영이 안되고 `Count++`을 불러오기 전의 데이터를 그대로 가져감
- 📝 해결방안
    - 하던 일이 끝날때까지 interrup를 받지 않는다
    - 무작정 막으면 비효율적일 수 있다.

## OS에서 race condition (2/3) - Preempt a process running in kernel?

![스크린샷 2023-03-01 오후 12.23.17.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.23.17.png)

- 두 프로세스의 address space 간에서는 data sharing이 없음
- 그러나 📌 **system call을 하는 동안에는 kernel address space의 data를 access하게 됨** (share)
- 이 작업 중간에 CPU를 preempt해가면 race condition 발생
- If you preempt CPU while in kernel mode…
    
    ![스크린샷 2023-03-01 오후 12.25.17.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.25.17.png)
    
    - 📌 해결책: 커널 모드에서 수행 중일 때는 (📝 할당시간이 끝나도) CPU를 preempt하지 않음, 커널 모드에서 사용자 모드로 돌아갈때 preempt. 할당시간을 더 받아도 큰 문제가 없다.

## OS에서의 race condition (3/3) - multi processor

![스크린샷 2023-03-01 오후 12.28.52.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.28.52.png)

- 어떤 CPU가 마지막으로 count를 store 했는가? → **race condition**
- multi processor의 경우 interrupt enable/disable로 해결 되지 않음
- 해결책:
    - 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법
    - 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법

## 📌 Process Synchronization 문제

- 공유 데이터 (shared data)의 동시 접근 (concurrent access)은 데이터의 불일치 문제 (inconsistency)를 발생시킬 수 있다.
- 일관성 (consistency) 유지를 위해서는 협력 프로세스 (cooperating process)간의 실행 순서 (orderly execution)를 정해주는 메커니즘 필요
- **Race condition**
    
    ![스크린샷 2023-03-01 오후 12.36.04.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.36.04.png)
    
    - 여러 프로세스들이 동시에 공유 데이터 (shared data)를 접근하는 상황
    - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- race condition을 막기 위해서는 concurrent process는 동기화 (synchronize) 되어야 한다.

## 📌 The Ciritical-Section Problem

- n 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 📌 **critical section**이 존재
- problem
    
    ![스크린샷 2023-03-01 오후 12.39.04.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.39.04.png)
    
    - 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 **critical section**에 들어갈 수 없어야 한다

> 📝 메모
그러면 전체 코드를 공유 데이터에 접근하는 코드인지 아닌지로 2분법적으로 구분할 수 있다.
> 

## Initial Attemps to Solve Problem

- 두 개의 프로세스가 있다고 가정 P0, P1
- 프로세스들의 일반적인 구조
    
    ![스크린샷 2023-03-01 오후 2.03.04.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.03.04.png)
    
- 프로세스들은 수행의 동기화 (synchronize)를 위해 몇몇 변수를 공유할 수 있다 → synchronization variable

> 📝 메모
entry section과 exit section과 같이 코드적으로 해결하는 방법
> 

## 프로그램적 해결법의 충족 조건

- Mutual Exlcusison (상호 배제)
    - 프로세스 Pi가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다
- Progress (진행)
    - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야한다
- Bounded Waiting (유한 대기)
    - 프로세스가 critical section에 들어가려고 요청한 후 부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다
- 가정
    - 모든 프로세스의 수행 속도는 0보다 크다
    - 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다

> 📝 메모
첫 번째 것은 굉장히 당연하다. 우리말로 유추하자면 상호 배제 즉, 배타적으로 접근해야한다는 말이다. 위와 같이 파란색의 코드로 표시. 두 번째는 진행이며, 아무도 들어가있지 않으면, 들어가고자 하면 들어가게 해야한다. 아무도 못들어가게 되는 문제점이 있기 때문에 생겨났다. 세 번째는 기다리는 시간에 있어서 유한해야한다. 즉, starvation이 생기지 않아야한다는 것과 동일. 어떻게 해야 위를 만족하면서 소프트웨어적으로 구현하는지?
> 

## Algorithm 1

- Synchronization variable
    
    ![스크린샷 2023-03-01 오후 2.11.24.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.11.24.png)
    
- Process P0
    
    ![스크린샷 2023-03-01 오후 2.11.59.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.11.59.png)
    
    - Satisfies mutual exclusion, but not progress
    - 즉, 과잉양보: 반드시 한번씩 교대로 들어가야만 함 (swap-turn)
    - 그가 turn 을 내값으로 바꿔줘야만 내가 들어갈 수 있음
    - 특정 프로세스가 더 빈번히 critical section을 들어가야 한다면?

> 📝 메모
while문을 돌면서 turn으로 process를 체크. 위 코드는 mutual exclusion을 만족 (while), 하지만 progress 조건을 만족하지 못한다. 반드시 교대로 들어가게 코드가 작성되어있음. 빈도가 균일하지 않을 수 있다. 극단적으로 다른 한쪽이 들어가지 않으면 결국 turn 도 바뀌지 않기 때문에, 서로의 turn이 돌아오지 않는다. → Algorithm 2 → turn 만 고려하면 안되겠다.
> 

## Algorithm 2

- Synchronization variables
    - `boolean flag[2]`
    - initially `flag [모두] = false;` /* no one is in Critical section*
    - Pi ready to enter its critical section if (`flag [i] == true`)
- Process Pi
    
    ![스크린샷 2023-03-01 오후 2.20.37.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.20.37.png)
    
- mutual exclusion을 만족하지만, progress requirement는 만족하지 못한다.
- 둘 다 2행까지 수행 후 끊임없이 양보하는 상황 발생 가능

> 📝 메모
- 상대방의 flag를 체크. 만약에 상대방이 flag를 체크하지 않았다면, 내가 들어간다. 내가 들어가고 싶다면 flag를 들어서 표시를 하고, 상대방이 flag를 들었는지 체크하고, 들고있으면 기다려준다.
- 서로 깃발만 들고 있으면, 아무도 못들어가기 때문에 progress requirement를 만족하지 못한다. 즉, 깃발을 내려놓으려면 critical section에 한번 들어갔다 나와야하기 때문이다. 동시에 들어가는 문제는 해결할 수 있지만 문제점이 있음. → Algorithm 3
> 

## Algorithm 3 (Peterson’s Algorithm)

- Combined synchronization variables of algorithm 1 and 2
- Process Pi
    
    ![스크린샷 2023-03-01 오후 2.25.55.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.25.55.png)
    
- **세 조건을 모두 충족시킨다**; solves the critical section problem for two processes.
- 문제점: **Busy Waiting**! (= spin lock) (계속 CPU와 memory를 쓰면서 wait)
    - lock을 걸어 다른 프로세스의 접근을 막음과 동시에 spin

> 📝 메모
- 자기가 들어가겠다는 의사 표현을 하고, turn을 상대방으로 바꾼다. 상대방이 깃발을 들고 있고, 상대방 차례라면 기다려준다. 하지만, 상대방이 깃발을 들고 있고, 나의 차례라면 들어가도 된다. 즉 두 가지를 모두 만족해야 들어갈 수 있다.
> 

## Synchronization Hardware

> ❓ atomic 하게 수행할 수 있다는 것은 무슨 말인가?
> 
- 하드웨어적으로 Test & modify를 **atomic**하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결
    
    ![스크린샷 2023-03-01 오후 2.37.20.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.37.20.png)
    
- Mutual Exclusion with Test & Set
    
    ![스크린샷 2023-03-01 오후 2.37.58.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.37.58.png)
    

> 📝 메모
 - 읽기와 쓰기를 같은 instruction에서 구현할 수 있다면 (동시에 실행할 수 있다면) 간단하게 해결할 수 있다. a 라는 데이터를 읽고 → 1 (TRUE)로 바꾼다.
- 프로그래머가 항상 이런 작업을 하면 번거롭다 → semaphores 추상 자료형
> 

## 📌 Semaphores

> 프로그래머 관점에서 동기화 문제 해결법
> 
- 앞의 방식들을 추상화시킴
- Semaphore S
    - integer variable
    - 아래의 두 가지 atomic 연산에 의해서만 접근 가능
        
        ![스크린샷 2023-03-01 오후 2.45.54.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.45.54.png)
        

> 📝 메모
 - semaphore를 사용하는 이유: 앞에 방식을 간단하게 제공할 수 있음, 공유자원을 획득하고 반납하는 처리를 담당한다. 📌 **P는 자원 획득, V는 다 사용하고 반납**하는것을 담당. 
- S 값이 양수가 되면 (= 다른 프로세스가 반납)
> 

## Critical Section of n Processes

![스크린샷 2023-03-01 오후 2.50.41.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.50.41.png)

- semaphore가 지원이 된다면 P와 V로 나타내고, 구현은 나중에
- busy-wait은 효율적이지 못함 (= spin lock)
- Blcok & Wakeup 방식의 구현 (= sleep lock)

## Block / Wakeup Implementation

- Semaphore를 다음과 같이 정의
    
    ![스크린샷 2023-03-01 오후 2.54.35.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.54.35.png)
    
- block 과 wakeup을 다음과 같이 가정
    - **block**: 커널은 block을 호출한 프로세스를 suspend시킴. 이 프로세스의 PCB를 semaphore에 대한 wait queu에 넣음
    - wakeup(P): blcok된 프로세스 P를 wakeup 시킴. 이 프로세스의 PCB를 ready queue로 옮김
        
        ![스크린샷 2023-03-01 오후 2.59.57.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.59.57.png)
        

## 📌 Implementation - block / wakeup version of `P()` & `V()`

- Semaphore 연산이 이제 다음과 같이 정의됨
    
    ![스크린샷 2023-03-01 오후 3.02.20.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.02.20.png)
    

> 📝 메모
연산에서는 S를 1 빼주고 음수라면, 이 process를 S.L에 연결시킨다음 block한다. 그러면, 이 친구는 block되어있다가 자원이 생기면 wake할 수 있다. 자원을 내놓았는데, 이 값이 양수라면 기다리는 프로세스가 없다는 얘기. 자원을 내놓았는데, 이 값이 음수라면 잠들어있는 프로세스 하나를 리스트에서 빼서 깨워주는 작업을 해야한다. 즉, 자원의 개수를 세는 것과 다르다. 즉, S의 값은 누군가를 깨워야하는지 말아야하는지를 결정하기 위해 존재함.
> 

## 📌 which is better?

- busy-wait vs. Block/wakeup?
- Blcok/wakeup overhead vs. Critical section 길이
    - Critical section의 길이가 긴 경우 block/wakeup이 적당
    - critical section의 길이가 매우 짧은 경우 block/wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있음 📝 block과 wakeup에 오버헤드가 들기 때문이다.
    - **일반적으로 block/wakeup 방식이 더 좋음**

## Two types of semaphores

- counting semaphore
    - 도메인이 0 이상인 임의의 정수값
    - 주로 resource counting에 사용
- Binary semaphore (=mutex)
    - 0 또는 1 값만 가질 수 있는 semaphore
    - 주로 mutual exclusion (lock/unlock)에 사용

## Deadlock and Starvation

> ❓ Deadlock과 starvation의 차이점?
> 
- Semaphore를 사용할 때 조심해야할 점
- **Deadlock**
    - 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상
- S와 Q가 1로 초기화된 semaphore라고 하자.
    
    ![스크린샷 2023-03-01 오후 3.12.54.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.12.54.png)
    
    - 서로 원하는 semaphore를 가지고 있기 때문에 영원히 기다려야함.
    - 벤치 프레스와 파워렉
    - 📌 해결법: 둘중의 하나를 먼저 얻어야 다음 semaphore를 얻을 수 있게 만들면 된다.
        - 파워렉을 써야 벤치를 쓰게 할 수 있어야한다 → 파워렉을 가지고 경쟁 → but 유의해야함.
- **Starvation**
    - **indefinite blocking**. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상

## Classical Problems of Synchronization

- Bounded-Buffer Problem (Producer-Consumer Problem)
- Readers and Writers Problem
- Dining-Philosophers Problem

## Bounded-Buffer Problem (Producer-Consumer Problem)

![스크린샷 2023-03-01 오후 3.24.20.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.24.20.png)

- buffer의 크기가 유한한 환경에서 생산자-소비자 문제
    - 주황색이 데이터가 들어있는 buffer
- 문제점
    - 공유 버퍼 → 생산자 둘이 도착해서 동시에 데이터를 만들어 집어넣으면 문제가 생긴다.
        - 📝 따라서 그냥하는게 아니라 lock을 걸어서 비어있는 버퍼에 데이터를 집어넣고 lock을 풀어서 다른 생산자나 소비자가 접근할 수 있게 해야한다. 소비자도 마찬가지로 생각
    - 버퍼가 유한하다
        - 모두 꽉차있는 경우 소비자가 소비를 해줘야 생산자가 생산을 할 수 있다.
        - 소비자 입장에서는 모두 비워져버리면, 소비할 것이 없이 생산자가 생산할때까지 기다려줘야한다.

**Shared data**

- buffer 자체 및 buffer 조작 변수 (empty/full buffer의 시작 위치)

**Synchronization variables**

- mutual exclusion → Need binary semaphore (shared data의 mutual exclusion을 위해)
- resource count → Need integer semaphore (남은 full/empty buffer의 수 표시)

![스크린샷 2023-03-01 오후 3.36.56.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.36.56.png)

## Readers-Writers Problem

- 한 process가 DB에 write 중 일 때 다른 process가 접근하면 안됨
- **📌 read는 동시에 여럿이 해도 됨 → 위의 semapore와 다름 → staravation이 발생 가능**
- solution
    - writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기중인 reader들을 다 DB에 접근하게 해준다
    - writer는 대기 중이 reader가 하나도 없을 때 DB접근이 허용된다
    - 일단 writer가 DB에 접근 중이면 Reader들은 접근이 금지된다
    - Writer가 DB에서 빠져나가야만 Reader의 접근이 허용된다.

**Shared data**

- DB 자체
- readcount; 현재 DB에 접근 중인 Reader의 수

**Synchronization variables**

- mutex → 공유 변수 readcount를 접근하는 코드 (critical section)의 mutual exclusion 보장을 위해 사용, binary semaphore
- db →  Reader와 writer가 공유 DB 자체를 올바르게 접근하게 하는 역할

![스크린샷 2023-03-01 오후 3.47.57.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.47.57.png)

> 📝 메모
Writer → 공유 데이터(DB)에 대해 P 연산으로 lock을 걸었다.
Reader → 읽을때 다른 사람의 접근에 대한 lock을 걸면 비효율적, 다만 읽을때의 write에 대한 lock은 걸어야 한다.
신호등이 없는 도로에서 횡단을 하려고 할때 → 언제 건너야 하는가?
> 

## Dining-Philosophers Problem

![스크린샷 2023-03-01 오후 3.18.10.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.18.10.png)

- **Synchronization variables**
    
    ![스크린샷 2023-03-01 오후 4.00.43.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.00.43.png)
    
- **Philosopher i**
    
    ![스크린샷 2023-03-01 오후 4.01.23.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.01.23.png)
    

> 📝 메모 
- 밥을 먹기 위해 양쪽의 젓가락을 잡아야한다. → 왼쪽이 이미 잡고 있다면 (공유자원을 갖고 있다면) 사용할 때까지 기다려야 한다.
- 모두 동시에 왼쪽 젓가락을 잡게 되면 영원히 먹지 못하고 모두 굶어 죽는다.
> 
- solution의 문제점:
    - Deadlock 가능성
    - 모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우
- 해결 방안
    - 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
    - 젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.
        
        ![스크린샷 2023-03-01 오후 4.06.19.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.06.19.png)
        
        - 먼저 상태를 건들어서 lock을 걸고 푼다. test → 젓가락을 잡을 수 있나? V 연산은 0 →1로 바꿔줌
    - 비대칭
        - 짝수 (홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록

## 📌 Monitor

> semaphore와 monitor의 차이점은?
> 
- Semaphore의 문제점
    - 코딩하기 힘들다
    - 정확성 (correctness)의 입증이 어렵다
    - 자발적 협력 (voluntary cooperation)이 필요하다
    - 한 번의 실수가 모든 시스템에 치명적 영향
- 예)
    
    ![스크린샷 2023-03-01 오후 4.17.35.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.17.35.png)
    
- **동시 수행중인 프로세스 사이에서 abstract data type (ADT)의 안전한 공유를 보장하기 위한 High level synchronization construct**
    
    ![스크린샷 2023-03-01 오후 4.19.08.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.19.08.png)
    
    - class 객체 지향 프로그래밍
    
    ![스크린샷 2023-03-01 오후 4.19.38.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.19.38.png)
    
    - 이 경우에는 📌 **lock을 걸 필요가 없다** → monitor가 프로세스의 동시 접근을 허락하지 않기 때문
- 모니터 내에서는 한번에 하나의 프로세스만이 활동 가능
- 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요 없음
- 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 **condition variable** 사용 → 값을 가지고 있지 않음
    - `condition x, y;`
- condition variable은 `wait`와 `signal` 연산에 의해서만 접근 가능
    - `x.wait();`
        - `x.wait()`을 invoke한 프로세스는 다른 프로세스가 `x.signal()`을 invoke하기 전까지 suspend된다
    - `x.signal();`
        - `x.signal()`은 정확하게 하나의 suspend된 프로세스를 resume한다.
        - Suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.

### Bounded-Buffer Problem에 적용

![스크린샷 2023-03-01 오후 4.27.41.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.27.41.png)

- lock을 걸 필요가 없고, semaphore가 필요 없다.
- semaphore과 monitor 버전의 code는 상호 변환이 쉽다.
- ❓ full 과 empty의 차이점은?

### Dining Philosophers에 적용

![스크린샷 2023-03-01 오후 4.57.03.png](src/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.57.03.png)

- 밥을 먹거나(`eat()`) 생각하거나(`think()`)를 반복
- 젓가락을 잡는 행위는 monitor 내부에 구현
    - 철학자 각각의 상태 → 공유 데이터 → 상호 변경이 가능하기 때문